name: Run SLURM Jobs (Self-Hosted, Subfolder Support)

permissions:
  contents: write

on:
  push:
    paths:
      - "input/**"

jobs:
  run-slurm:
    runs-on: self-hosted

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare working and output directories
        run: |
          mkdir -p output
          export SLURM_TMP_BASE="/tmp/slurm_jobs_${GITHUB_RUN_ID}"
          mkdir -p "$SLURM_TMP_BASE"
          echo "SLURM_TMP_BASE=$SLURM_TMP_BASE" >> $GITHUB_ENV

      - name: Copy input subfolders to SLURM temp dir
        run: |
          for jobdir in input/*; do
            if [ -d "$jobdir" ]; then
              jobname=$(basename "$jobdir")
              mkdir -p "${SLURM_TMP_BASE}/${jobname}"
              cp -r "$jobdir"/* "${SLURM_TMP_BASE}/${jobname}/" || true
              echo "Copied $jobdir to ${SLURM_TMP_BASE}/${jobname}"
            fi
          done
          echo "Directory structure in temp dir:"
          tree "${SLURM_TMP_BASE}" || ls -R "${SLURM_TMP_BASE}"

      - name: Submit jobs to SLURM
        run: |
          > joblist.txt
          for jobdir in "${SLURM_TMP_BASE}"/*; do
            if [ -d "$jobdir" ]; then
              for script in "$jobdir"/*.sh "$jobdir"/*.txt; do
                [ -f "$script" ] || continue
                fname=$(basename "$script")
                jobname=$(basename "$jobdir")
                echo "Submitting $fname from $jobname..."
                jobid=$(sbatch --parsable \
                  --chdir="$jobdir" \
                  --output="${jobdir}/${fname}-%j.out" \
                  "$script")
                echo "${jobname}/${fname}:$jobid" >> joblist.txt
              done
            fi
          done
          echo "Submitted jobs:"
          cat joblist.txt || true

      - name: Wait for jobs to finish
        run: |
          echo "Waiting for SLURM jobs to complete..."
          while read -r line; do
            [ -n "$line" ] || continue
            jobid="${line##*:}"
            while squeue -j "$jobid" | grep -q "$jobid"; do
              sleep 10
            done
          done < joblist.txt

      - name: Check job exit codes and mark completed input dirs
        run: |
          echo "Checking SLURM job exit codes..."
          failed_any=0

          # Build list of all job directories involved
          cut -d: -f1 joblist.txt | awk -F/ '{print $1}' | sort -u \
            > jobdirs_all.txt || true

          : > failed_dirs.txt

          while read -r line; do
            [ -n "$line" ] || continue
            entry="${line%%:*}"
            jobid="${line##*:}"
            jobdir="${entry%%/*}"

            state=$(scontrol show job "$jobid" \
              | awk -F= '/JobState=/{print $2}' | awk '{print $1}')
            exitcode=$(scontrol show job "$jobid" \
              | awk -F= '/ExitCode=/{print $2}' | awk '{print $1}')

            echo "Job $jobid in dir $jobdir finished with state=$state exitcode=$exitcode"
            if [[ "$state" != "COMPLETED" ]]; then
              failed_any=1
              echo "$jobdir" >> failed_dirs.txt
            fi
          done < joblist.txt

          sort -u failed_dirs.txt > failed_dirs_sorted.txt || true
          sort -u jobdirs_all.txt > jobdirs_all_sorted.txt || true

          # Directories where all jobs completed successfully
          comm -23 jobdirs_all_sorted.txt failed_dirs_sorted.txt \
            > completed_dirs.txt || true

          echo "Job directories with all jobs completed successfully:"
          cat completed_dirs.txt || echo "(none)"

          if [[ $failed_any -ne 0 ]]; then
            echo "One or more jobs failed at the Slurm level."
            exit 1
          fi

      - name: Collect all output files
        run: |
          echo "Collecting all output files..."
          for jobdir in "${SLURM_TMP_BASE}"/*; do
            if [ -d "$jobdir" ]; then
              jobname=$(basename "$jobdir")
              mkdir -p "output/${jobname}"
              cp "$jobdir"/* "output/${jobname}/" || true
            fi
          done
          rm -rf "${SLURM_TMP_BASE}"

      - name: Commit output and remove completed inputs
        run: |
          # Remove input directories that completed successfully
          if [ -s completed_dirs.txt ]; then
            echo "Removing input directories for completed jobs..."
            while read -r d; do
              [ -n "$d" ] || continue
              if [ -d "input/$d" ]; then
                rm -rf "input/$d"
                echo "Deleted input/$d"
              fi
            done < completed_dirs.txt
          else
            echo "No completed job directories to remove."
          fi

          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin \
            https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git

          # Stage both outputs and input deletions only
          git add -A output/ input/
          git commit -m "Add SLURM job output and remove completed inputs from run ${GITHUB_RUN_ID} [skip ci]" \
            || echo "No changes to commit"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload output as artifact
        uses: actions/upload-artifact@v4
        with:
          name: slurm-job-output
          path: output/